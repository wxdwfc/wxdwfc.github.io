<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[WXD's official site]]></title>
  <link href="http://xmm4ok69.com/atom.xml" rel="self"/>
  <link href="http://xmm4ok69.com/"/>
  <updated>2016-02-14T20:43:28+08:00</updated>
  <id>http://xmm4ok69.com/</id>
  <author>
    <name><![CDATA[Xmm]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Paper Reading Yesquel: Scalable SQL Storage for Web Applications]]></title>
    <link href="http://xmm4ok69.com/blog/2016/02/14/paper-reading-yesquel-scalable-sql-storage-for-web-applications/"/>
    <updated>2016-02-14T16:55:26+08:00</updated>
    <id>http://xmm4ok69.com/blog/2016/02/14/paper-reading-yesquel-scalable-sql-storage-for-web-applications</id>
    <content type="html"><![CDATA[<h2>Yesquel: scalable SQL storage for Web applications,Marcos K et al. 2015</h2>

<p><br />
&emsp;&emsp;现今传统的SQL数据库正在成为许多网络应用，比如邮件系统，社交网络的系统瓶颈。在论文里说到，这些系统使用两种方式来避免这种情况发生：</p>

<ul style="padding-left:50px;"  >
    <li><p>使用一个缓存层比如memcached来避免对于数据库的直接访问。</p></li>
    <li><p>不使用传统数据库，而使用一个NOSQL的数据库来代替SQL的数据库。</p></li>
</ul>




<!-- more -->


<p>&emsp;&emsp;然而，NOSQL相比传统的SQL数据库有许多问题，主要在于功能性的问题。，许多NOSQL的数据库提供不同的特性，如下图作者总结的；</p>

<p>   <img src="http://xmm4ok69.com/images/yes/fig1.png" alt="Alt text" /></p>

<p>&emsp;&emsp;相比来说，SQL的兼容性相对来说就好很多。</p>

<p>&emsp;&emsp;所以这篇论文的主要贡献在提出了一个SQL数据库的架构，为NOSQL的workload来优化。正如michael stonebraker的一篇paper所说的一样，类似SQL数据库的这种one size fits all的时代已经过去了，想要有更好的性能就要为一个workload来优化。</p>

<p>&emsp;&emsp;所以Yesquel针对的是web applications，如论文中表述,</p>

<blockquote>
Web applications have lots of data and users. Queries used to serve Web pages are small and numerous: each query touches a small amount of data, but because there are many simultaneous queries, in aggregate they access large amounts of data. Queries are latency-sensitive, as Web pages must display quickly.
</blockquote>


<p>&emsp;&emsp;ok基于这些背景知识可以来看这篇paper的关键点了。其实这还是一篇比较容易理解的paper。</p>

<h3>Yesquel的架构及整体设计</h3>

<p>&emsp;&emsp;Yesquel的架构主要由客户端的SQL解析器和一个分布式的数据引擎组成。Yesquel将SQL解析放在客户端而不是服务器端，也就是说所有的SQL query都由客户端解析成数据层的访问再由客户端向服务器端发起访问。这样带来的好处是服务器的SQL解析器不会成为性能的瓶颈，因为解析的性能随着client的增多会变得更好；这里我认为带来的trade-off是解析器没有办法获得全局的数据库信息，这样在做一些query的时候没有办法做最好的优化。不过在web app的情况下这应该不会成为很大的问题。具体的系统架构如下图所示，</p>

<p>   <img src="http://xmm4ok69.com/images/yes/fig1.png" alt="Alt text" /></p>

<p>&emsp;&emsp;分布式的数据引擎需要支持数据的键值查找，以及对键的range query。同时数据引擎需要有非常好的扩展性和支持并发的请求，这些我认为都是比较具有挑战的，尤其是在一个分布式的环境中。</p>

<blockquote>
<ul>
<li>Provide locality, so that neighboring keys are often in the
same server, allowing them to be fetched together during
enumeration.
<li>Minimize the number of network round trips for locating
keys.
<li>Balance load by spreading keys across servers, even if the
workload is non-uniform and changes over time. This requires
continuous and adaptive rebalancing without pausing
or disrupting other operations.
<li>Provide reasonable semantics under concurrent operations.
For example, while a client changes an ordered
map, another client may be enumerating its keys, and the
result should be sensible.
<li>Provide good performance under concurrent operations.
</blockquote>


<p>&emsp;&emsp;作者也特别提到这样的设计对OLAP的workload不是特别友好。因为OLAP通常需要执行非常长的时间，同时需要访问非常多的数据。如果由客户端做join或者aggregation的话显然需要client自己做，这样client就需要访问非常多的数据。</p>

<h3>Yesquel的分布式B树YDBT</h3>

<p>&emsp;&emsp;Yesquel使用了一个Distributed balanced BTree来作为他的数据引擎的支持。关于这个B树其实没有什么特别的，我自己总结来说他有三个特点，</p>

<ol style="padding-left:50px;"  >
    <li><p>使用了一个back-down search算法使得对对B树的搜索在大部分情况下可以使用本地缓存。</p></li>
    <li><p>使用了一个简单的事务型存储服务来储存树的节点，这样不需要对树进行额外的并发控制保护，可以直接利利用事务来做并发控制</p></li>
    <li><p>使用了新的分裂算法，即将对于树的节点访问load也作为树节点的分裂依据。</p></li>
</ol>


<p>&emsp;&emsp;对于第一点来说，他主要的算法如下，</p>

<p>   <img src="http://xmm4ok69.com/images/yes/fig3.png" alt="Alt text" /></p>

<p>&emsp;&emsp;这个算法假设树除了叶子节点外都可以cache到本地，因此大部分树的查找操作都可以不用网络读取远端节点，这样就会非常的高效。这个算法需要解决的问题是，他不去维护cache的consistency，因为这会有非常大的开销，所以由于cache的过期会使得算法一直重试下去。于是解决方法是设一个阈值(论文中是100)，当超过这个阈值的时候就invalidate cache，采用一个slow path来重新查找key(这篇论文是采用transaction来作slow path的查找)。</p>

<p>&emsp;&emsp;这个算法我觉得有个非常有意思的点，就是他可以在尽可能的利用cache避免网络操作，这我认为在分布式环境下是个很大的开销。这感觉可以和RDMA frendly data structure结合在一起考虑，但是需要考虑如何做并发控制。</p>

<p>&emsp;&emsp;其他的两点我觉得比较trivial，就不讨论了。</p>

<p>&emsp;&emsp;最后我觉得他们的论文非常厉害的一点是他们的系统非常给人robost的感觉。他们的项目的官网是</p>

<blockquote>
<a href="http://www.yesquel.com/">http://www.yesquel.com/</a>
</blockquote>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[相机成像原理]]></title>
    <link href="http://xmm4ok69.com/blog/2016/01/24/xiang-ji-cheng-xiang-yuan-li/"/>
    <updated>2016-01-24T19:47:18+08:00</updated>
    <id>http://xmm4ok69.com/blog/2016/01/24/xiang-ji-cheng-xiang-yuan-li</id>
    <content type="html"><![CDATA[<p><br />
&emsp;&emsp;       嘛，第一篇blog就交个最近在学习的摄影了。</p>

<p>&emsp;&emsp;“并不是为了学习摄影而去摄影，而是遇到什么美丽的东西可以以最好的方式记录下来。”</p>

<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;by myself
<br /></p>

<!-- more -->


<h3>1. 为什么会有虚像和实像？</h3>

<p>   <img src="http://xmm4ok69.com/images/blog_1_1.jpg" alt="Alt text" /></p>

<p>   非对焦点上的光不会被汇聚在感光元件上的一个点，所以会产生虚像。
   只有汇聚成点的像才能最清晰的被成像。</p>

<p>   如上图所示，黑点所处平面的点会被汇聚成一个点。对焦(我的理解)应该就是调整镜头到CMOS(假设使用CMOS的相机）的距离来调整对焦平面。</p>

<h3>2. 景深</h3>

<p>   大脑会将一部分不清晰的像解析为清晰的像（神奇的大脑），那些可被大脑再不清晰的范围被称作景深。</p>

<h3>3. 焦距</h3>

<p>   焦距是指镜头和感光元件之间的距离。</p>

<p>   <img src="http://xmm4ok69.com/images/blog_1_2.jpg" alt="Alt text" /></p>

<p>   焦距越小，接受的弥散斑就越小，景深就变大。不过我个人认为这句话是对于焦点后的后方(上图中的蓝色的点)</p>

<h3>4. 光圈</h3>

<p>   <img src="http://xmm4ok69.com/images/blog_1_3.jpg" alt="Alt text" /></p>

<p>   那既然有弥散斑，我用个挡板挡住弥散斑不就可以让照片景深变大吗？对的，这挡板就是光圈。</p>

<p>   <br /></p>

<hr />

<p>   <br /></p>

<p>&emsp;&emsp; 顺便的吐槽，我觉得现在很多人实在太浮躁了。帮别人拍摄照片，明明光线不好，于是就把过曝很过分的照片当好的，完全不care那些后期下能变的很好的照片，sigh。为朋友圈发个不low的照片而找人拍照又不好好静下心好好弄照片的行为我实在看不懂。</p>

<p>   &emsp;&emsp; 嘛，反正这些照片别人也不会当回事，朋友圈的照片几天就会忘了。正好给我当练习的素材。大概也没有人会关注这里:)</p>

<p>   <br /></p>

<hr />

<p>   <br /></p>

<p>   Reference: <a href="http://www.cnblogs.com/yjf512/archive/2013/03/20/2970970.html">http://www.cnblogs.com/yjf512/archive/2013/03/20/2970970.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://xmm4ok69.com/blog/2016/01/22/hello-world/"/>
    <updated>2016-01-22T22:34:14+08:00</updated>
    <id>http://xmm4ok69.com/blog/2016/01/22/hello-world</id>
    <content type="html"><![CDATA[<p>Hello!</p>
]]></content>
  </entry>
  
</feed>
